/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int  init_para(int x_pixel, int y_pixel, int time_slot, int cut_x_pixel, int cut_y_pixel); // idb
int  decrypt(__int16 a1, __int16 a2, int a3);
void find_maxandmin();
unsigned int double_click();
signed int identify_hv_line();
signed int fetch_object_sample_2level();
signed int sampledata_to_normalizing();
signed int feature_to_transform();
signed int feature_to_match();
signed int sampledata_to_standardizing();
signed int  result_to_num(int a1);
int  fetch_object_sample(unsigned char *buf, signed int pointnum); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_10; // weak
int x_scale = 720; // weak
int y_scale = 1280; // weak
int end_x_scale = 720; // weak
int end_y_scale = 1280; // weak
int tm_slot = 100; // weak
_UNKNOWN e; // weak
char NormDy[2] = " "; // weak
int start_x_scale[]; // weak
int start_y_scale; // weak
int data_x[]; // weak
_BYTE byte_5974[132]; // idb
int data_y[]; // weak
int max_x; // weak
int min_x; // weak
int max_y; // weak
int min_y; // weak
signed __int16 point_count[2]; // idb
int tm_stamp1; // weak
int tm_stamp; // weak
char config_char; // weak
char byte_5C6D; // weak
char byte_5C6E; // weak
char byte_5C6F; // weak
char byte_5C70; // weak
char byte_5C71; // weak
int data_sample_x[]; // weak
int dword_5C78[]; // weak
int start_x; // weak
int data_sample_y[]; // weak
int start_y; // weak
signed __int16 index_sample_x[2]; // idb
_UNKNOWN data_normal_x; // weak
int dword_5FA4; // weak
_UNKNOWN unk_5FA8; // weak
_UNKNOWN data_normal_y; // weak
int dword_6138; // weak
_UNKNOWN unk_613C; // weak
int wide_ratio; // weak
_UNKNOWN result_x; // weak
_UNKNOWN unk_6308; // weak
_UNKNOWN result_y; // weak
_UNKNOWN unk_6348; // weak
_UNKNOWN sdry_th; // weak
_UNKNOWN mdry_th; // weak
char slect_1; // weak
char slect_2; // weak
char slect_3; // weak
char slect_6; // weak
char slect_7; // weak
char slect_8; // weak
char slect_9; // weak
char slect_a; // weak
char slect_b; // weak
char slect_c; // weak
char slect_d; // weak
char slect_e; // weak
char slect_g; // weak
char slect_h; // weak
char slect_4; // weak
char slect_5; // weak
char slect_0; // weak
char slect_v; // weak
char slect_k; // weak
char slect_L; // weak
char slect_m; // weak
char slect_n; // weak
char slect_o; // weak
char slect_p; // weak
char slect_q; // weak
char slect_r; // weak
char slect_s; // weak
char slect_f; // weak
char slect_u; // weak
char slect_w; // weak
char slect_y; // weak
char slect_z; // weak
_UNKNOWN datax; // weak
_UNKNOWN datay; // weak
_UNKNOWN data_x_in; // weak
_UNKNOWN data_y_in; // weak
_UNKNOWN wide_mode; // weak


//----- (00000000) --------------------------------------------------------
int  init_para(int x_pixel, int y_pixel, int time_slot, int cut_x_pixel, int cut_y_pixel)
{
  x_scale = x_pixel;
  y_scale = y_pixel;
  start_x_scale[0] = cut_x_pixel;
  end_x_scale = x_pixel - cut_x_pixel;
  start_y_scale = cut_y_pixel;
  end_y_scale = y_pixel - cut_y_pixel;
  tm_slot = time_slot;
  return x_pixel;
}
// 1984: using guessed type int x_scale;
// 1988: using guessed type int y_scale;
// 198C: using guessed type int end_x_scale;
// 1990: using guessed type int end_y_scale;
// 1994: using guessed type int tm_slot;
// 5798: using guessed type int start_x_scale[];
// 579C: using guessed type int start_y_scale;

//----- (00000040) --------------------------------------------------------
int  decrypt(__int16 a1, __int16 a2, int a3)
{
  unsigned int v3; // r6@1
  unsigned int v4; // r7@1
  int v5; // r12@1
  int v6; // r3@1
  int v7; // r5@1
  int v8; // r4@1
  int v9; // r1@1
  __int16 v10; // r0@1
  signed int v11; // r6@1
  signed int v12; // r7@1
  int v13; // r5@2
  signed int v14; // r11@2
  signed int v15; // r9@2
  int *v16; // r2@3
  int result; // r0@3

  v3 = (unsigned char)a2;
  v4 = (unsigned char)a1;
  v5 = a2 & 3;
  v6 = a1 & 3;
  v7 = ((unsigned char)((v6 + v5 * v6 + 13) * (v6 + v5 * v6 + 13)) >> 2) & 1;
  v8 = v7 + 2 * (((_BYTE)v6 + (_BYTE)v5 * (_BYTE)v6 + 13) * ((_BYTE)v6 + (_BYTE)v5 * (_BYTE)v6 + 13) & 1) + 1;
  v9 = a2 & 0xFF00;
  v10 = a1 & 0xFF00;
  v11 = v3 >> 2;
  v12 = v4 >> 2;
  if ( v8 == 3 )
  {
    v15 = 3;
    v14 = 15;
    LOBYTE(v13) = 4;
    LOBYTE(v8) = 2;
  }
  else
  {
    v13 = 5 - (v7 + 2 * (((_BYTE)v6 + (_BYTE)v5 * (_BYTE)v6 + 13) * ((_BYTE)v6 + (_BYTE)v5 * (_BYTE)v6 + 13) & 1));
    v14 = (unsigned char)((1 << (6 - v8)) - 1);
    v15 = (unsigned char)((1 << v8) - 1);
  }
  v16 = &start_x_scale[a3];
  result = v10 & 0xF00 | (((v11 >> v13) | ((v14 & v11) << v8)) & 3 | 4
                                                                   * (((v11 >> v13) | ((v14 & v11) << v8)) & 0x3C | v6)) ^ 0xEA;
  v16[2] = (v9 | (((v12 >> v8) | ((v15 & v12) << v13)) & 3 | 4 * (((v12 >> v8) | ((v15 & v12) << v13)) & 0x3C | v5)) ^ 0xEAu) >> 4;
  v16[152] = result;
  return result;
}
// 5798: using guessed type int start_x_scale[];

//----- (00000138) --------------------------------------------------------
void find_maxandmin()
{
  int v0; // r6@1
  int v1; // r7@1
  int v2; // r5@2
  int v3; // r4@2
  int v4; // r12@2
  int v5; // r0@2
  int v6; // r10@2
  int v7; // r8@2
  signed int v8; // r3@2
  int v9; // r1@4
  int v10; // r2@4

  v0 = data_x[0];
  v1 = data_y[0];
  max_x = data_x[0];
  min_x = data_x[0];
  max_y = data_y[0];
  min_y = data_y[0];
  if ( point_count[0] > 1 )
  {
    v2 = data_x[0];
    v3 = data_x[0];
    v4 = data_y[0];
    v5 = data_y[0];
    v6 = data_y[0];
    v7 = data_x[0];
    v8 = 1;
    while ( 1 )
    {
      v9 = data_x[v8];
      v10 = data_y[v8];
      if ( v9 > v0 )
        v2 = data_x[v8];
      if ( v9 < v7 )
        v3 = data_x[v8];
      if ( v1 < v10 )
        v4 = data_y[v8];
      if ( v6 > v10 )
        v5 = data_y[v8];
      if ( point_count[0] <= ++v8 )
        break;
      v6 = v5;
      v1 = v4;
      v7 = v3;
      v0 = v2;
    }
    max_x = v2;
    min_x = v3;
    max_y = v4;
    min_y = v5;
  }
}
// 57A0: using guessed type int data_x[];
// 59F8: using guessed type int data_y[];
// 5C50: using guessed type int max_x;
// 5C54: using guessed type int min_x;
// 5C58: using guessed type int max_y;
// 5C5C: using guessed type int min_y;

//----- (0000020C) --------------------------------------------------------
unsigned int double_click()
{
  int *v0; // r3@1
  int v1; // r2@1
  bool v2; // nf@3
  unsigned char v3; // vf@3
  int v4; // r2@3
  unsigned int result; // r0@8
  bool v6; // cf@8
  bool v7; // zf@8

  v0 = &x_scale;
  v1 = max_x;
  if ( max_x < 0 )
    v1 = -max_x;
  v3 = __OFSUB__(v1, x_scale >> 3);
  v2 = v1 - (x_scale >> 3) < 0;
  v4 = max_y;
  if ( !(v2 ^ v3) )
    goto LABEL_18;
  if ( max_y < 0 )
    v4 = -max_y;
  if ( v4 < y_scale >> 3 )
  {
    result = 10 * (tm_stamp1 - tm_stamp) / (unsigned int)tm_slot - 2;
    v6 = result >= 0xF;
    v7 = result == 15;
    if ( result > 0xF )
      result = 0;
    else
      v0 = 0;
    if ( !v7 && v6 )
    {
      tm_stamp = result;
      tm_stamp1 = result;
    }
    else
    {
      tm_stamp = (int)v0;
      tm_stamp1 = (int)v0;
      result = 36;
    }
  }
  else
  {
LABEL_18:
    result = 0;
    tm_stamp = 0;
    tm_stamp1 = 0;
  }
  return result;
}
// 1984: using guessed type int x_scale;
// 1988: using guessed type int y_scale;
// 1994: using guessed type int tm_slot;
// 5C50: using guessed type int max_x;
// 5C58: using guessed type int max_y;
// 5C64: using guessed type int tm_stamp1;
// 5C68: using guessed type int tm_stamp;

//----- (000002A4) --------------------------------------------------------
signed int identify_hv_line()
{
  signed int v0; // r6@1
  signed int result; // r0@2
  int v2; // r2@3
  signed int v3; // r10@4
  int v4; // r0@4
  signed int v5; // r10@5
  int v6; // r4@6
  signed int v7; // r7@7
  int *v8; // r3@10
  int v9; // r0@10
  signed int v10; // r1@10
  int v11; // r2@13
  int v12; // r4@14
  int v13; // r10@19
  int v14; // r4@20
  signed int v15; // r7@21
  int *v16; // r3@24
  int v17; // r0@24
  signed int v18; // r1@24
  int v19; // r2@27
  int v20; // r4@28
  int v21; // r0@32
  int v22; // r1@32
  signed int v23; // r7@33
  int *v24; // r12@36
  signed int v25; // r2@36
  int v26; // r10@36
  int v27; // r3@39
  int v28; // r1@40
  int v29; // r0@52
  int v30; // r1@52
  signed int v31; // r4@53
  int *v32; // r12@56
  signed int v33; // r2@56
  int v34; // r10@56
  int v35; // r3@59
  int v36; // r1@60

  v0 = point_count[0];
  if ( point_count[0] <= 6 )
    return 0;
  v2 = max_x - min_x;
  if ( max_x - min_x >= x_scale >> 2 )
  {
    v3 = y_scale;
    v4 = max_y - min_y;
    goto LABEL_5;
  }
  v3 = y_scale;
  v4 = max_y - min_y;
  if ( max_y - min_y < y_scale >> 1 )
  {
LABEL_5:
    v5 = v3 >> 4;
    if ( start_x_scale[point_count[0] + 1] >= data_x[0] )
    {
      v21 = 3 * v4 / point_count[0];
      v22 = data_y[0];
      if ( point_count[0] % 3 )
        LOWORD(v23) = point_count[0] - 6;
      else
        LOWORD(v23) = point_count[0] - 3;
      point_count[0] = v23;
      v23 = (signed __int16)v23;
      if ( (signed __int16)v23 <= 3 )
      {
LABEL_44:
        if ( config_char & 2 )
          result = 33;
        else
          result = 215;
      }
      else
      {
        v24 = data_y;
        v25 = 3;
        v26 = v21 + v5;
        while ( 1 )
        {
          v27 = v24[3];
          v25 += 3;
          v28 = v27 >= v22 ? v27 - v22 : v22 - v27;
          if ( v28 > v26 )
            break;
          v24 += 3;
          if ( v23 <= v25 )
            goto LABEL_44;
          v22 = v27;
        }
        result = 214;
      }
    }
    else
    {
      v6 = data_y[0];
      if ( point_count[0] % 3 )
        LOWORD(v7) = point_count[0] - 6;
      else
        LOWORD(v7) = point_count[0] - 3;
      point_count[0] = v7;
      v7 = (signed __int16)v7;
      if ( (signed __int16)v7 <= 3 )
      {
LABEL_48:
        if ( config_char & 1 )
          result = 32;
        else
          result = 213;
      }
      else
      {
        v8 = data_y;
        v9 = 3 * v4 / v0 + v5;
        v10 = 3;
        while ( 1 )
        {
          v11 = v8[3];
          v10 += 3;
          v12 = v6 <= v11 ? v11 - v6 : v6 - v11;
          if ( v12 > v9 )
            break;
          v8 += 3;
          if ( v10 >= v7 )
            goto LABEL_48;
          v6 = v11;
        }
        result = 212;
      }
    }
    return result;
  }
  v13 = x_scale >> 3;
  if ( start_x_scale[point_count[0] + 151] >= data_y[0] )
  {
    v29 = 3 * v2 / point_count[0];
    v30 = data_x[0];
    if ( point_count[0] % 3 )
      LOWORD(v31) = point_count[0] - 6;
    else
      LOWORD(v31) = point_count[0] - 3;
    point_count[0] = v31;
    v31 = (signed __int16)v31;
    if ( (signed __int16)v31 <= 3 )
    {
LABEL_64:
      if ( config_char & 8 )
        result = 35;
      else
        result = 211;
    }
    else
    {
      v32 = data_x;
      v33 = 3;
      v34 = v29 + v13;
      while ( 1 )
      {
        v35 = v32[3];
        v33 += 3;
        v36 = v35 >= v30 ? v35 - v30 : v30 - v35;
        if ( v36 > v34 )
          break;
        v32 += 3;
        if ( v31 <= v33 )
          goto LABEL_64;
        v30 = v35;
      }
      result = 210;
    }
  }
  else
  {
    v14 = data_x[0];
    if ( point_count[0] % 3 )
      LOWORD(v15) = point_count[0] - 6;
    else
      LOWORD(v15) = point_count[0] - 3;
    point_count[0] = v15;
    v15 = (signed __int16)v15;
    if ( (signed __int16)v15 <= 3 )
    {
LABEL_68:
      if ( config_char & 4 )
        result = 34;
      else
        result = 209;
    }
    else
    {
      v16 = data_x;
      v17 = 3 * v2 / v0 + v13;
      v18 = 3;
      while ( 1 )
      {
        v19 = v16[3];
        v18 += 3;
        v20 = v19 >= v14 ? v19 - v14 : v14 - v19;
        if ( v20 > v17 )
          break;
        v16 += 3;
        if ( v15 <= v18 )
          goto LABEL_68;
        v14 = v19;
      }
      result = 208;
    }
  }
  return result;
}
// 1984: using guessed type int x_scale;
// 1988: using guessed type int y_scale;
// 5798: using guessed type int start_x_scale[];
// 57A0: using guessed type int data_x[];
// 59F8: using guessed type int data_y[];
// 5C50: using guessed type int max_x;
// 5C54: using guessed type int min_x;
// 5C58: using guessed type int max_y;
// 5C5C: using guessed type int min_y;
// 5C6C: using guessed type char config_char;

//----- (00000604) --------------------------------------------------------
signed int fetch_object_sample_2level()
{
  signed int v0; // r7@1
  int v1; // r12@1
  int v2; // r0@1
  signed int v3; // r4@5
  int v4; // r8@5
  signed int v5; // r3@5
  int v6; // r5@25
  int v7; // r8@25
  signed int v8; // ST04_4@25
  int v9; // r12@25
  int *v10; // r0@25
  int *v11; // r6@25
  int v12; // r5@25
  int v13; // r12@25
  int *v14; // r0@25
  int *v15; // r0@6
  int v16; // r2@9
  int v17; // r1@9
  int v18; // r5@10
  int v19; // r6@13
  bool v20; // zf@15
  bool v21; // nf@15
  unsigned char v22; // vf@15
  bool v23; // zf@18
  bool v24; // nf@18
  unsigned char v25; // vf@18
  bool v26; // zf@22
  bool v27; // nf@22
  unsigned char v28; // vf@22
  bool v29; // zf@26
  bool v30; // nf@26
  unsigned char v31; // vf@26
  int *v32; // r5@29
  void *v33; // r2@31
  int *v34; // r12@31
  void *v35; // r0@31
  int *v36; // r1@31
  int v37; // r3@31
  int v38; // r5@32
  int v39; // t1@32
  int v40; // t1@32

  v0 = index_sample_x[0];
  v1 = data_sample_y[0];
  v2 = data_sample_x[0];
  start_y = data_sample_y[0];
  if ( index_sample_x[0] <= 1 )
    v1 = 1;
  start_x = data_sample_x[0];
  if ( index_sample_x[0] > 1 )
  {
    v3 = 1;
    v4 = data_sample_x[0];
    v5 = 1;
    while ( 1 )
    {
      v16 = data_sample_x[v5];
      v17 = data_sample_y[v5];
      if ( v16 < v2 )
        v18 = v2 - v16;
      else
        v18 = v16 - v2;
      if ( v17 < v1 )
        v19 = v1 - v17;
      else
        v19 = v17 - v1;
      v22 = __OFSUB__(v18, 1);
      v20 = v18 == 1;
      v21 = v18 - 1 < 0;
      if ( v18 <= 1 )
      {
        v22 = __OFSUB__(v19, 1);
        v20 = v19 == 1;
        v21 = v19 - 1 < 0;
      }
      if ( !((unsigned char)(v21 ^ v22) | v20) )
      {
        v25 = __OFSUB__(v3, 95);
        v23 = v3 == 95;
        v24 = v3 - 95 < 0;
        if ( v3 <= 95 )
        {
          v25 = __OFSUB__(v0, 50);
          v23 = v0 == 50;
          v24 = v0 - 50 < 0;
        }
        if ( (unsigned char)(v24 ^ v25) | v23 )
        {
          v28 = __OFSUB__(v18, 7);
          v26 = v18 == 7;
          v27 = v18 - 7 < 0;
          if ( v18 <= 7 )
          {
            v28 = __OFSUB__(v19, 7);
            v26 = v19 == 7;
            v27 = v19 - 7 < 0;
          }
          if ( (unsigned char)(v27 ^ v28) | v26 )
          {
            v31 = __OFSUB__(v18, 3);
            v29 = v18 == 3;
            v30 = v18 - 3 < 0;
            if ( v18 <= 3 )
            {
              v31 = __OFSUB__(v19, 3);
              v29 = v19 == 3;
              v30 = v19 - 3 < 0;
            }
            if ( !((unsigned char)(v30 ^ v31) | v29) )
            {
              v32 = &start_x_scale[v3];
              v32[514] = (v2 + v16) >> 1;
              v32[615] = (v1 + v17) >> 1;
              ++v3;
            }
          }
          else
          {
            v6 = (v2 + v16) >> 1;
            v7 = (v1 + v17) >> 1;
            v8 = v7 + v1;
            v9 = (v6 + v2) >> 1;
            v10 = &start_x_scale[v3 + 1];
            v10[514] = v6;
            v11 = &start_x_scale[v3];
            v10[615] = v7;
            v11[514] = v9;
            v11[615] = v8 >> 1;
            v12 = v10[514];
            v13 = v10[615];
            v14 = &start_x_scale[v3 + 2];
            v14[514] = (v16 + v12) >> 1;
            v14[615] = (v17 + v13) >> 1;
            v3 += 3;
          }
        }
        v15 = &start_x_scale[v3];
        v15[514] = v16;
        v15[615] = v17;
        ++v3;
        v1 = v17;
        v4 = v16;
      }
      if ( v0 <= ++v5 )
        break;
      v2 = v4;
    }
    start_x = v4;
    start_y = v1;
    index_sample_x[0] = v3;
    if ( (signed __int16)v3 > 1 )
    {
      v33 = &data_normal_x;
      v34 = data_sample_x;
      v35 = &data_normal_y;
      v36 = data_sample_y;
      v37 = 0;
      do
      {
        v39 = *((_DWORD *)v33 + 1);
        v33 = (char *)v33 + 4;
        v38 = v39;
        v37 += 4;
        v40 = *((_DWORD *)v35 + 1);
        v35 = (char *)v35 + 4;
        v34[1] = v38;
        ++v34;
        v36[1] = v40;
        ++v36;
      }
      while ( v37 != 4 * ((signed __int16)v3 - 1) );
    }
  }
  else
  {
    index_sample_x[0] = v1;
  }
  return 121;
}
// 5798: using guessed type int start_x_scale[];
// 5C74: using guessed type int data_sample_x[];
// 5E04: using guessed type int start_x;
// 5E08: using guessed type int data_sample_y[];
// 5F98: using guessed type int start_y;

//----- (000007F0) --------------------------------------------------------
signed int sampledata_to_normalizing()
{
  void *v0; // r0@1
  void *v1; // r12@1
  unsigned int v2; // r3@1
  void *v3; // r1@1
  void *v4; // r2@1
  signed int v5; // r1@3
  int v6; // r6@4
  int v7; // r4@5
  int v8; // r2@5
  signed __int16 v9; // r5@7
  signed int v10; // r9@7
  int *v11; // r8@7
  int *v12; // r7@7
  signed int v13; // r6@7
  signed int v14; // r4@7
  int *v15; // r3@8
  signed int v16; // r2@8
  int v17; // r1@10
  int v18; // t1@10
  signed int v19; // r0@15
  signed int v20; // r3@16
  signed int v21; // r3@20
  int *v22; // r2@20
  int v23; // r1@20
  int v24; // r12@20
  int v25; // t1@20
  int v26; // t1@25
  bool v27; // zf@26

  v0 = &data_normal_x;
  v1 = &data_normal_y;
  v2 = 0;
  v3 = &data_normal_y;
  v4 = &data_normal_x;
  do
  {
    *((_DWORD *)v4 + 1) = 0;
    v4 = (char *)v4 + 4;
    *((_DWORD *)v3 + 1) = 0;
    v3 = (char *)v3 + 4;
  }
  while ( v4 != &data_normal_y );
  v5 = index_sample_x[0];
  if ( index_sample_x[0] > 0 )
  {
    v6 = 4 * ((unsigned __int16)(index_sample_x[0] - 1) + 1);
    do
    {
      v7 = data_sample_x[v2 / 4];
      v8 = data_sample_y[v2 / 4];
      v2 += 4;
      *((_DWORD *)v0 + 1) = v7;
      v0 = (char *)v0 + 4;
      *((_DWORD *)v1 + 1) = v8;
      v1 = (char *)v1 + 4;
    }
    while ( v2 != v6 );
    if ( v5 > 15 )
    {
      v9 = 2;
      v10 = index_sample_x[0];
      v11 = (int *)&unk_613C;
      v12 = (int *)&unk_5FA8;
      v13 = 32;
      v14 = 2;
      while ( 1 )
      {
        v19 = (signed __int16)(v13 / v5);
        if ( (signed __int16)v19 > 1 )
          v20 = (signed __int16)(v13 / v5);
        else
          v20 = 2;
        if ( (signed __int16)v19 <= 1 )
          v19 = v20;
        v21 = v20;
        v22 = &start_x_scale[v21];
        v23 = start_x_scale[v21 + 514];
        v25 = *v12;
        ++v12;
        v24 = v25;
        if ( v23 )
        {
          if ( v14 != v19 )
            v22[514] = (v23 + v24) >> 1;
          v15 = &start_x_scale[v21];
          if ( v14 != v19 )
            *(v12 - 1) = 0;
          v16 = v15[615];
          v26 = *v11;
          ++v11;
          v17 = v26;
          if ( v16 )
            goto LABEL_26;
        }
        else
        {
          v15 = &start_x_scale[v21];
          v22[514] = v24;
          v16 = v15[615];
          if ( v14 != v19 )
            *(v12 - 1) = 0;
          v18 = *v11;
          ++v11;
          v17 = v18;
          if ( v16 )
          {
LABEL_26:
            v27 = v14 == v19;
            if ( v14 != v19 )
              v16 += v17;
            ++v9;
            if ( v14 != v19 )
              v16 >>= 1;
            if ( v14 != v19 )
              v15[615] = v16;
            v14 = v9;
            if ( !v27 )
              *(v11 - 1) = 0;
            v13 += 16;
            if ( v10 < v9 )
              return 121;
            goto LABEL_14;
          }
        }
        ++v9;
        v27 = v14 == v19;
        v14 = v9;
        v15[615] = v17;
        if ( !v27 )
          *(v11 - 1) = v16;
        v13 += 16;
        if ( v10 < v9 )
          return 121;
LABEL_14:
        v5 = v10;
      }
    }
  }
  return 121;
}
// 5798: using guessed type int start_x_scale[];
// 5C74: using guessed type int data_sample_x[];
// 5E08: using guessed type int data_sample_y[];

//----- (0000098C) --------------------------------------------------------
signed int feature_to_transform()
{
  signed int result; // r0@2
  int v1; // r4@3
  int *v2; // r2@3
  int v3; // r5@3
  int *v4; // r12@3
  int v5; // r1@3
  int v6; // r0@3
  int v7; // r3@3
  int v8; // t1@4
  int v9; // t1@4

  if ( wide_ratio <= 4 )
  {
    v1 = dword_5FA4;
    v2 = &dword_6138;
    v3 = dword_6138;
    v4 = &dword_5FA4;
    v5 = dword_6138;
    v6 = dword_5FA4;
    v7 = 0;
    while ( 1 )
    {
      *(_DWORD *)((char *)&result_x + v7) = 2 * (v6 - v1);
      *(_DWORD *)((char *)&result_y + v7) = 2 * (v5 - v3);
      v7 += 4;
      if ( v7 == 64 )
        break;
      v8 = v4[1];
      ++v4;
      v6 = v8;
      v9 = v2[1];
      ++v2;
      v5 = v9;
    }
    result = 121;
  }
  else
  {
    result = 78;
  }
  return result;
}
// 5FA4: using guessed type int dword_5FA4;
// 6138: using guessed type int dword_6138;
// 62C8: using guessed type int wide_ratio;

//----- (00000A14) --------------------------------------------------------
signed int feature_to_match()
{
  int v0; // r4@2
  char *v1; // r6@2
  void *v2; // r10@2
  int v3; // r8@2
  signed int v4; // r11@2
  signed int v5; // r5@2
  signed int v6; // r12@2
  signed int v7; // r0@2
  char *v8; // r1@2
  void *v9; // r9@2
  int v10; // r2@3
  int v11; // t1@3
  int v12; // r3@3
  int v13; // t1@3
  int v14; // r7@3
  int v15; // t1@3
  int v16; // r2@4
  int v17; // r3@6
  int v18; // t1@6
  int v19; // r3@9
  signed int v20; // r1@20
  void *v21; // r8@20
  char *v22; // r10@20
  signed int v23; // r12@20
  signed int v24; // r0@20
  signed int v25; // r6@20
  signed int v26; // r7@20
  int v27; // r2@21
  int v28; // t1@21
  int v29; // t1@21
  signed int v30; // r7@22
  signed int v31; // r6@22
  int v32; // r8@22
  int v33; // r7@23
  signed int v34; // r6@23
  signed int v35; // r3@23
  int v36; // r10@26
  signed int result; // r0@30
  signed int v38; // r1@34
  signed int v39; // r9@34
  int v40; // r8@34
  void *v41; // r5@34
  signed int v42; // r12@34
  signed int v43; // r7@34
  signed int v44; // r0@34
  signed int v45; // r6@34
  int v46; // r2@35
  int v47; // t1@35
  int v48; // t1@35
  signed int v49; // r6@36
  signed int v50; // r0@36
  int v51; // r8@36
  int v52; // r0@37
  int v53; // r6@37
  signed int v54; // r3@37
  int v55; // r0@40
  int v56; // r3@42
  int v57; // r11@43
  int v58; // [sp+0h] [bp-50h]@1
  int v59; // [sp+Ch] [bp-44h]@2
  int v60; // [sp+1Ch] [bp-34h]@1
  int v61; // [sp+20h] [bp-30h]@1
  signed int v62; // [sp+24h] [bp-2Ch]@1

  v58 = 0;
  v61 = 0;
  v62 = 1000;
  v60 = 0;
  do
  {
    v0 = 0;
    v8 = (char *)&e + 128 * v58;
    v1 = v8;
    v59 = (int)(v8 + 64);
    v2 = &result_y;
    v3 = (int)(v8 + 64);
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    LOWORD(v8) = 1;
    v9 = &result_x;
    do
    {
      v11 = *((_DWORD *)v1 + 1);
      v1 += 4;
      v10 = v11;
      v13 = *((_DWORD *)v9 + 1);
      v9 = (char *)v9 + 4;
      v12 = v13;
      v15 = *(_DWORD *)(v3 + 4);
      v3 += 4;
      v14 = v15;
      if ( v10 >= v12 )
        v16 = v10 - v12;
      else
        v16 = v12 - v10;
      v18 = *((_DWORD *)v2 + 1);
      v2 = (char *)v2 + 4;
      v17 = v18;
      if ( v5 < v16 )
        v5 = v16;
      if ( v14 >= v17 )
        v19 = v14 - v17;
      else
        v19 = v17 - v14;
      v8 = (char *)(unsigned __int16)((_WORD)v8 + 1);
      if ( v4 < v19 )
        v4 = v19;
      if ( v0 < v19 + v16 )
        v0 = v19 + v16;
      v7 += v16;
      v6 += v19;
    }
    while ( (_UNKNOWN *)v8 != &loc_10 );
    if ( v7 <= 383 && sdry_th > v6 && v5 <= 44 && mdry_th > v4 )
    {
      v20 = 0;
      v21 = &result_x;
      v22 = (char *)&e + 128 * v58;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v26 = 0;
      do
      {
        v28 = *((_DWORD *)v21 + 1);
        v21 = (char *)v21 + 4;
        v27 = v28;
        v29 = *((_DWORD *)v22 + 1);
        v22 += 4;
        v26 += v27;
        v25 += v29;
        v24 += v27 * v27;
        v23 += v29 * v29;
        v20 += v27 * v29;
      }
      while ( v21 != &unk_6308 );
      v30 = v26 >> 4;
      v31 = v25 >> 4;
      v32 = (v20 >> 4) - v30 * v31;
      if ( v32 > 0 )
      {
        v33 = v30 * v30;
        v34 = (v23 >> 4) - v31 * v31;
        v35 = v34 == 0;
        if ( v24 >> 4 == v33 )
          v35 = 1;
        if ( v35 )
        {
          v36 = 100;
        }
        else
        {
          v36 = v32 * (100 * v32 / ((v24 >> 4) - v33)) / v34;
          if ( v36 <= 55 )
            goto LABEL_28;
        }
        v38 = 0;
        v39 = v5;
        v40 = v59;
        v41 = &result_y;
        v42 = 0;
        v43 = 0;
        v44 = 0;
        v45 = 0;
        do
        {
          v47 = *((_DWORD *)v41 + 1);
          v41 = (char *)v41 + 4;
          v46 = v47;
          v48 = *(_DWORD *)(v40 + 4);
          v40 += 4;
          v45 += v46;
          v44 += v48;
          v43 += v46 * v46;
          v42 += v48 * v48;
          v38 += v46 * v48;
        }
        while ( v41 != &unk_6348 );
        v49 = v45 >> 4;
        v50 = v44 >> 4;
        v51 = (v38 >> 4) - v49 * v50;
        if ( v51 > 0 )
        {
          v52 = v50 * v50;
          v53 = v49 * v49;
          v54 = v42 >> 4 == v52;
          if ( v43 >> 4 == v53 )
            v54 = 1;
          if ( v54 )
          {
            v55 = 100;
          }
          else
          {
            v55 = v51 * (100 * v51 / ((v43 >> 4) - v53)) / ((v42 >> 4) - v52);
            if ( v55 <= 55 )
              goto LABEL_28;
          }
          v56 = (v55 + v36) >> 1;
          if ( v56 > 69 )
          {
            v57 = v0 + v39 + v4;
            if ( v57 + 2 * (100 - v56) < v62 )
            {
              v62 = v57 + 2 * (100 - v56);
              v61 = (v55 + v36) >> 1;
              v60 = v58;
            }
          }
        }
      }
    }
LABEL_28:
    ++v58;
  }
  while ( v58 != 123 );
  index_sample_x[0] = 0;
  if ( v61 > 69 )
  {
    result = byte_5974[v60 - 604];
    if ( result == 255 )
      result = 78;
  }
  else
  {
    result = 78;
  }
  return result;
}

//----- (00000D40) --------------------------------------------------------
signed int sampledata_to_standardizing()
{
  int v0; // r5@1
  int v1; // r6@1
  signed int v2; // r8@1
  signed int v3; // r10@1
  int v4; // r11@6
  int *v5; // r4@6
  int *v6; // r7@6
  int *v7; // r9@6
  int v8; // t1@8
  int v9; // r2@8
  signed int v10; // r0@8
  int v11; // t1@10
  int v12; // r0@10
  int v13; // r2@10
  signed int result; // r0@15

  v0 = min_x;
  v1 = min_y;
  v2 = max_x - min_x;
  v3 = max_y - min_y;
  if ( max_x - min_x < 1 )
    v2 = 1;
  if ( v3 < 1 )
    v3 = 1;
  if ( index_sample_x[0] > 0 )
  {
    v4 = *(signed __int16 *)NormDy;
    v5 = data_sample_x;
    v6 = data_sample_y;
    v7 = &dword_5C78[(unsigned __int16)(index_sample_x[0] - 1)];
    do
    {
      while ( 1 )
      {
        v8 = *v5;
        ++v5;
        v9 = v0 - v8;
        v10 = 32 * (v8 - v0);
        if ( v0 >= v8 )
          v10 = 32 * v9;
        v11 = *v6;
        ++v6;
        *(v5 - 1) = v10 / v2;
        v12 = v11 - v1;
        v13 = v1 - v11;
        if ( v1 >= v11 )
          break;
        *(v6 - 1) = v4 * v12 / v3;
        if ( v5 == v7 )
          goto LABEL_12;
      }
      *(v6 - 1) = v13 * v4 / v3;
    }
    while ( v5 != v7 );
  }
LABEL_12:
  if ( fetch_object_sample_2level() == 78 || sampledata_to_normalizing() == 78 || feature_to_transform() == 78 )
    result = 121;
  else
    result = feature_to_match();
  return result;
}
// 5C50: using guessed type int max_x;
// 5C54: using guessed type int min_x;
// 5C58: using guessed type int max_y;
// 5C5C: using guessed type int min_y;
// 5C74: using guessed type int data_sample_x[];
// 5C78: using guessed type int dword_5C78[];
// 5E08: using guessed type int data_sample_y[];

//----- (00000E68) --------------------------------------------------------
signed int  result_to_num(int a1)
{
  signed int result; // r0@3

  switch ( a1 )
  {
    case 42:
      if ( byte_5C6F & 0x20 )
        result = 85;
      else
        result = 246;
      break;
    default:
      result = 0;
      break;
    case 50:
      if ( byte_5C70 & 0x20 )
        result = 101;
      else
        result = 251;
      break;
    case 51:
      if ( byte_5C70 & 1 )
        result = 96;
      else
        result = 239;
      break;
    case 54:
      if ( byte_5C70 & 2 )
        result = 97;
      else
        result = 241;
      break;
    case 55:
      if ( byte_5C70 & 8 )
        result = 99;
      else
        result = 249;
      break;
    case 56:
      if ( byte_5C70 & 0x10 )
        result = 100;
      else
        result = 250;
      break;
    case 57:
      if ( byte_5C70 & 4 )
        result = 98;
      else
        result = 242;
      break;
    case 60:
      if ( byte_5C6F & 2 )
        result = 81;
      else
        result = 232;
      break;
    case 62:
      if ( byte_5C6F & 4 )
        result = 82;
      else
        result = 233;
      break;
    case 64:
      if ( byte_5C6F & 1 )
        result = 80;
      else
        result = 231;
      break;
    case 76:
      if ( byte_5C6E & 0x10 )
        result = 68;
      else
        result = 228;
      break;
    case 94:
      if ( byte_5C6F & 8 )
        result = 83;
      else
        result = 234;
      break;
    case 97:
      if ( byte_5C6D & 0x40 )
        result = 54;
      else
        result = 222;
      break;
    case 98:
      if ( byte_5C6E & 4 )
        result = 66;
      else
        result = 226;
      break;
    case 99:
      if ( byte_5C6D & 0x10 )
        result = 52;
      else
        result = 220;
      break;
    case 100:
      if ( (unsigned int)(unsigned char)byte_5C6D >> 7 )
        result = 55;
      else
        result = 223;
      break;
    case 101:
      if ( byte_5C6D & 8 )
        result = 51;
      else
        result = 219;
      break;
    case 103:
      if ( byte_5C6D & 0x20 )
        result = 53;
      else
        result = 221;
      break;
    case 104:
      if ( byte_5C71 & 1 )
        result = 112;
      else
        result = 243;
      break;
    case 107:
      if ( byte_5C71 & 2 )
        result = 113;
      else
        result = 244;
      break;
    case 109:
      if ( byte_5C6D & 4 )
        result = 50;
      else
        result = 218;
      break;
    case 110:
      if ( byte_5C6E & 1 )
        result = 64;
      else
        result = 224;
      break;
    case 111:
      if ( byte_5C6D & 1 )
        result = 48;
      else
        result = 216;
      break;
    case 112:
      if ( byte_5C6E & 0x20 )
        result = 69;
      else
        result = 247;
      break;
    case 113:
      if ( byte_5C6E & 8 )
        result = 67;
      else
        result = 227;
      break;
    case 114:
      if ( byte_5C71 & 8 )
        result = 115;
      else
        result = 248;
      break;
    case 115:
      if ( byte_5C6E & 0x40 )
        result = 70;
      else
        result = 229;
      break;
    case 117:
      if ( (unsigned int)(unsigned char)byte_5C6E >> 7 )
        result = 71;
      else
        result = 230;
      break;
    case 118:
      if ( byte_5C6F & 0x10 )
        result = 84;
      else
        result = 235;
      break;
    case 119:
      if ( byte_5C6D & 2 )
        result = 49;
      else
        result = 217;
      break;
    case 121:
      if ( byte_5C71 & 4 )
        result = 114;
      else
        result = 245;
      break;
    case 122:
      if ( byte_5C6E & 2 )
        result = 65;
      else
        result = 225;
      break;
  }
  return result;
}
// 5C6D: using guessed type char byte_5C6D;
// 5C6E: using guessed type char byte_5C6E;
// 5C6F: using guessed type char byte_5C6F;
// 5C70: using guessed type char byte_5C70;
// 5C71: using guessed type char byte_5C71;

//----- (000012C8) --------------------------------------------------------
int  fetch_object_sample(unsigned char *buf, signed int pointnum)
{
  signed int v2; // r9@1
  unsigned char *v3; // r11@1
  char *v4; // r3@2
  unsigned char *v5; // r2@2
  char v6; // t1@3
  int v7; // r6@70
  unsigned char *v8; // r4@70
  __int16 v9; // r7@70
  int v10; // r2@70
  int v11; // r12@71
  __int16 v12; // r3@71
  unsigned char *v13; // r5@72
  int v14; // r2@72
  int v15; // r0@73
  signed int v16; // r2@75
  int v17; // r3@75
  int v18; // r0@78
  signed int v19; // r11@78
  int v20; // r1@78
  int *v21; // r5@79
  signed __int16 v22; // r4@79
  int v23; // r9@79
  int v24; // r8@79
  int *v25; // r6@79
  signed __int16 v26; // r12@79
  signed int v27; // r7@79
  bool v28; // zf@80
  bool v29; // nf@80
  unsigned char v30; // vf@80
  int *v31; // r7@83
  int v32; // r1@85
  int v33; // r1@90
  int v34; // r3@96
  int v35; // t1@96
  int v36; // r2@96
  int v37; // t1@96
  int v38; // r0@97
  int v39; // r1@100
  signed int v40; // r6@105
  signed int v41; // r5@108
  int v42; // r0@113
  int result; // r0@113
  int v44; // [sp+0h] [bp-38h]@79
  int v45; // [sp+4h] [bp-34h]@79
  int v46; // [sp+8h] [bp-30h]@79
  int v47; // [sp+Ch] [bp-2Ch]@79

  max_x = 0;
  min_x = 0;
  max_y = 0;
  min_y = 0;
  start_x = 0;
  start_y = 0;
  slect_1 = 0;
  slect_2 = 0;
  slect_3 = 0;
  slect_6 = 0;
  slect_7 = 0;
  slect_8 = 0;
  slect_9 = 0;
  slect_a = 0;
  slect_b = 0;
  slect_c = 0;
  slect_d = 0;
  slect_e = 0;
  slect_g = 0;
  slect_h = 0;
  slect_4 = 0;
  slect_5 = 0;
  slect_0 = 0;
  slect_v = 0;
  slect_k = 0;
  slect_L = 0;
  slect_m = 0;
  slect_n = 0;
  slect_o = 0;
  slect_p = 0;
  slect_q = 0;
  slect_r = 0;
  slect_s = 0;
  v2 = pointnum;
  v3 = buf;
  slect_f = 0;
  slect_u = 0;
  slect_w = 0;
  slect_y = 0;
  slect_z = 0;
  if ( pointnum > 149 )
    return 0;
  v4 = (char *)&tm_stamp + 3;
  v5 = buf + 1;
  do
  {
    v6 = (v5++)[1];
    *v4 = v6;
    v4 = v4;
  }
  while ( v4 != &byte_5C71 );
  if ( !(byte_5C6D & 1) )
    slect_o = 1;
  if ( !(byte_5C6D & 2) )
    slect_w = 1;
  if ( !(byte_5C6D & 4) )
    slect_m = 1;
  if ( !(byte_5C6D & 8) )
    slect_e = 1;
  if ( !(byte_5C6D & 0x10) )
    slect_c = 1;
  if ( !(byte_5C6D & 0x20) )
    slect_g = 1;
  if ( !(byte_5C6D & 0x40) )
    slect_a = 1;
  if ( !((unsigned int)(unsigned char)byte_5C6D >> 7) )
    slect_d = 1;
  if ( !(byte_5C6E & 1) )
    slect_n = 1;
  if ( !(byte_5C6E & 2) )
    slect_z = 1;
  if ( !(byte_5C6E & 4) )
    slect_b = 1;
  if ( !(byte_5C6E & 8) )
    slect_q = 1;
  if ( !(byte_5C6E & 0x10) )
    slect_L = 1;
  if ( !(byte_5C6E & 0x20) )
    slect_p = 1;
  if ( !(byte_5C6E & 0x40) )
    slect_s = 1;
  if ( !((unsigned int)(unsigned char)byte_5C6E >> 7) )
    slect_u = 1;
  if ( !(byte_5C6F & 1) )
    slect_1 = 1;
  if ( !(byte_5C6F & 2) )
    slect_4 = 1;
  if ( !(byte_5C6F & 4) )
    slect_5 = 1;
  if ( !(byte_5C6F & 8) )
    slect_0 = 1;
  if ( !(byte_5C6F & 0x10) )
    slect_v = 1;
  if ( !(byte_5C6F & 0x20) )
    slect_f = 1;
  if ( !(byte_5C70 & 1) )
    slect_3 = 1;
  if ( !(byte_5C70 & 2) )
    slect_6 = 1;
  if ( !(byte_5C70 & 4) )
    slect_9 = 1;
  if ( !(byte_5C70 & 8) )
    slect_7 = 1;
  if ( !(byte_5C70 & 0x10) )
    slect_8 = 1;
  if ( !(byte_5C70 & 0x20) )
    slect_2 = 1;
  if ( !(byte_5C71 & 1) )
    slect_h = 1;
  if ( !(byte_5C71 & 2) )
    slect_k = 1;
  if ( !(byte_5C71 & 4) )
    slect_y = 1;
  if ( !(byte_5C71 & 8) )
    slect_r = 1;
  if ( pointnum > 0 )
  {
    v7 = 0;
    v8 = buf;
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = v8[9] | (v8[8] << 8);
      *(_DWORD *)((char *)&datax + v7) = v11;
      v12 = _byteswap_ushort(*((_WORD *)v8 + 5));
      *(_DWORD *)((char *)&datay + v7) = v8[11] | (v8[10] << 8);
      data_y_in = v12;
      data_x_in = v11;
      ++v9;
      decrypt(v11, v12, v10);
      v10 = v9;
      v7 += 4;
      v8 += 4;
    }
    while ( v2 > v9 );
    v13 = v3;
    point_count[0] = v2;
    v14 = 0;
    do
    {
      v3[v14 * 4] = LOWORD(data_x[v14]) >> 8;
      v13[1] = data_x[v14];
      v13[2] = LOWORD(data_y[v14]) >> 8;
      v15 = data_y[v14];
      ++v14;
      v13[3] = v15;
      v13 += 4;
    }
    while ( v14 != (unsigned __int16)(v2 - 1) + 1 );
  }
  else
  {
    point_count[0] = pointnum;
  }
  find_maxandmin();
  if ( max_x - min_x < x_scale >> 2 )
  {
    v16 = y_scale;
    v17 = max_y - min_y;
    if ( max_y - min_y >= y_scale >> 1 )
      return identify_hv_line();
  }
  else
  {
    v16 = y_scale;
    v17 = max_y - min_y;
  }
  if ( v17 < v16 >> 3 && max_x - min_x >= x_scale >> 1 )
    return identify_hv_line();
  v18 = data_x[0];
  v19 = point_count[0];
  v20 = data_y[0];
  index_sample_x[0] = 0;
  start_x = data_x[0];
  start_y = data_y[0];
  data_sample_x[0] = data_x[0];
  data_sample_y[0] = data_y[0];
  max_x = data_x[0];
  max_y = data_y[0];
  min_x = data_x[0];
  min_y = data_y[0];
  if ( point_count[0] <= 1 )
  {
LABEL_119:
    result = result_to_num(78);
  }
  else
  {
    v21 = data_x;
    v22 = 1;
    v23 = data_x[0];
    v24 = data_y[0];
    v44 = data_x[0];
    v46 = data_x[0];
    v45 = data_y[0];
    v25 = data_y;
    v47 = data_y[0];
    v26 = 1;
    v27 = 1;
    while ( 1 )
    {
      v35 = v21[1];
      ++v21;
      v34 = v35;
      v37 = v25[1];
      ++v25;
      v36 = v37;
      if ( v18 > v34 )
        v38 = v18 - v34;
      else
        v38 = v34 - v18;
      if ( v20 > v36 )
        v39 = v20 - v36;
      else
        v39 = v36 - v20;
      if ( v27 > 99 )
      {
        start_x = v23;
        start_y = v24;
        max_x = v44;
        min_x = v46;
        max_y = v45;
        min_y = v47;
        goto LABEL_104;
      }
      v30 = __OFSUB__(v38, 8);
      v28 = v38 == 8;
      v29 = v38 - 8 < 0;
      if ( v38 <= 8 )
      {
        v30 = __OFSUB__(v39, 8);
        v28 = v39 == 8;
        v29 = v39 - 8 < 0;
      }
      if ( !((unsigned char)(v29 ^ v30) | v28) )
      {
        v31 = &start_x_scale[v27];
        v31[311] = v34;
        v31[412] = v36;
        if ( v34 <= v44 )
        {
          v32 = v46;
          if ( v46 >= v34 )
            v32 = v34;
          v46 = v32;
        }
        else
        {
          v44 = v34;
        }
        if ( v36 <= v45 )
        {
          v33 = v47;
          if ( v47 >= v36 )
            v33 = v36;
          v47 = v33;
        }
        else
        {
          v45 = v36;
        }
        ++v22;
        v24 = v36;
        v23 = v34;
        v27 = v22;
      }
      if ( ++v26 >= v19 )
        break;
      v20 = v24;
      v18 = v23;
    }
    start_x = v23;
    start_y = v24;
    max_x = v44;
    min_x = v46;
    max_y = v45;
    min_y = v47;
    if ( v27 <= 16 )
      goto LABEL_119;
LABEL_104:
    if ( max_x == min_x )
      v40 = 1;
    else
      v40 = max_x - min_x;
    if ( max_y == min_y )
      v41 = 1;
    else
      v41 = max_y - min_y;
    if ( v40 >= v41 )
    {
      wide_mode = 0;
      *(_WORD *)NormDy = 32;
      mdry_th = 45;
      wide_ratio = v40 / v41;
      sdry_th = 384;
    }
    else
    {
      wide_ratio = v41 / v40;
      wide_mode = 1;
      *(_WORD *)NormDy = 64;
      mdry_th = 90;
      sdry_th = 768;
      if ( v41 < 2 * v40 )
      {
        mdry_th = 81;
        sdry_th = 691;
        *(_WORD *)NormDy = (v41 << 6) / (2 * v40);
      }
    }
    index_sample_x[0] = v22;
    v42 = sampledata_to_standardizing();
    result = result_to_num(v42);
  }
  return result;
}
// 1984: using guessed type int x_scale;
// 1988: using guessed type int y_scale;
// 5798: using guessed type int start_x_scale[];
// 57A0: using guessed type int data_x[];
// 59F8: using guessed type int data_y[];
// 5C50: using guessed type int max_x;
// 5C54: using guessed type int min_x;
// 5C58: using guessed type int max_y;
// 5C5C: using guessed type int min_y;
// 5C68: using guessed type int tm_stamp;
// 5C6D: using guessed type char byte_5C6D;
// 5C6E: using guessed type char byte_5C6E;
// 5C6F: using guessed type char byte_5C6F;
// 5C70: using guessed type char byte_5C70;
// 5C71: using guessed type char byte_5C71;
// 5C74: using guessed type int data_sample_x[];
// 5E04: using guessed type int start_x;
// 5E08: using guessed type int data_sample_y[];
// 5F98: using guessed type int start_y;
// 62C8: using guessed type int wide_ratio;
// 6350: using guessed type char slect_1;
// 6351: using guessed type char slect_2;
// 6352: using guessed type char slect_3;
// 6353: using guessed type char slect_6;
// 6354: using guessed type char slect_7;
// 6355: using guessed type char slect_8;
// 6356: using guessed type char slect_9;
// 6357: using guessed type char slect_a;
// 6358: using guessed type char slect_b;
// 6359: using guessed type char slect_c;
// 635A: using guessed type char slect_d;
// 635B: using guessed type char slect_e;
// 635C: using guessed type char slect_g;
// 635D: using guessed type char slect_h;
// 635E: using guessed type char slect_4;
// 635F: using guessed type char slect_5;
// 6360: using guessed type char slect_0;
// 6361: using guessed type char slect_v;
// 6362: using guessed type char slect_k;
// 6363: using guessed type char slect_L;
// 6364: using guessed type char slect_m;
// 6365: using guessed type char slect_n;
// 6366: using guessed type char slect_o;
// 6367: using guessed type char slect_p;
// 6368: using guessed type char slect_q;
// 6369: using guessed type char slect_r;
// 636A: using guessed type char slect_s;
// 636B: using guessed type char slect_f;
// 636C: using guessed type char slect_u;
// 636D: using guessed type char slect_w;
// 636E: using guessed type char slect_y;
// 636F: using guessed type char slect_z;

// ALL OK, 12 function(s) have been successfully decompiled

